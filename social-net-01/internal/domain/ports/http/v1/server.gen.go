// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (PUT /friend/delete/{user_id})
	PutFriendDeleteUserId(ctx echo.Context, userId UserId) error

	// (PUT /friend/set/{user_id})
	PutFriendSetUserId(ctx echo.Context, userId UserId) error

	// (POST /login)
	PostLogin(ctx echo.Context) error

	// (POST /post/create)
	PostPostCreate(ctx echo.Context) error

	// (PUT /post/delete/{id})
	PutPostDeleteId(ctx echo.Context, id PostId) error

	// (GET /post/feed)
	GetPostFeed(ctx echo.Context, params GetPostFeedParams) error

	// (GET /post/get/{id})
	GetPostGetId(ctx echo.Context, id PostId) error

	// (PUT /post/update)
	PutPostUpdate(ctx echo.Context) error

	// (GET /user/get/{id})
	GetUserGetId(ctx echo.Context, id UserId) error

	// (POST /user/register)
	PostUserRegister(ctx echo.Context) error

	// (GET /user/search)
	GetUserSearch(ctx echo.Context, params GetUserSearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PutFriendDeleteUserId converts echo context to params.
func (w *ServerInterfaceWrapper) PutFriendDeleteUserId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutFriendDeleteUserId(ctx, userId)
	return err
}

// PutFriendSetUserId converts echo context to params.
func (w *ServerInterfaceWrapper) PutFriendSetUserId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutFriendSetUserId(ctx, userId)
	return err
}

// PostLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostLogin(ctx)
	return err
}

// PostPostCreate converts echo context to params.
func (w *ServerInterfaceWrapper) PostPostCreate(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostPostCreate(ctx)
	return err
}

// PutPostDeleteId converts echo context to params.
func (w *ServerInterfaceWrapper) PutPostDeleteId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id PostId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutPostDeleteId(ctx, id)
	return err
}

// GetPostFeed converts echo context to params.
func (w *ServerInterfaceWrapper) GetPostFeed(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPostFeedParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPostFeed(ctx, params)
	return err
}

// GetPostGetId converts echo context to params.
func (w *ServerInterfaceWrapper) GetPostGetId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id PostId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPostGetId(ctx, id)
	return err
}

// PutPostUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) PutPostUpdate(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutPostUpdate(ctx)
	return err
}

// GetUserGetId converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserGetId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id UserId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserGetId(ctx, id)
	return err
}

// PostUserRegister converts echo context to params.
func (w *ServerInterfaceWrapper) PostUserRegister(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostUserRegister(ctx)
	return err
}

// GetUserSearch converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserSearch(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserSearchParams
	// ------------- Required query parameter "first_name" -------------

	err = runtime.BindQueryParameter("form", true, true, "first_name", ctx.QueryParams(), &params.FirstName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first_name: %s", err))
	}

	// ------------- Required query parameter "last_name" -------------

	err = runtime.BindQueryParameter("form", true, true, "last_name", ctx.QueryParams(), &params.LastName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserSearch(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.PUT(baseURL+"/friend/delete/:user_id", wrapper.PutFriendDeleteUserId)
	router.PUT(baseURL+"/friend/set/:user_id", wrapper.PutFriendSetUserId)
	router.POST(baseURL+"/login", wrapper.PostLogin)
	router.POST(baseURL+"/post/create", wrapper.PostPostCreate)
	router.PUT(baseURL+"/post/delete/:id", wrapper.PutPostDeleteId)
	router.GET(baseURL+"/post/feed", wrapper.GetPostFeed)
	router.GET(baseURL+"/post/get/:id", wrapper.GetPostGetId)
	router.PUT(baseURL+"/post/update", wrapper.PutPostUpdate)
	router.GET(baseURL+"/user/get/:id", wrapper.GetUserGetId)
	router.POST(baseURL+"/user/register", wrapper.PostUserRegister)
	router.GET(baseURL+"/user/search", wrapper.GetUserSearch)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5fbWMq/V+l8AAAD//7yzC0nhJgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
